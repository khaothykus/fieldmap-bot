import os
import re
import time
from datetime import datetime, timedelta
from typing import Optional, Tuple, List

import yaml
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException

# ------------------------------------------------------------
# Regex para "dd/MM/yyyy HH:mm:ss"
# ------------------------------------------------------------
DATETIME_RX = re.compile(r"(\d{2}/\d{2}/\d{4})\s+(\d{2}:\d{2}:\d{2})")


# ------------------------------------------------------------
# Helpers de data/hora
# ------------------------------------------------------------
def _br_date_to_dt(txt: str) -> Optional[datetime]:
    """
    Converte 'dd/MM/yyyy HH:mm:ss' (ou 'dd/MM/yyyy HH:mm') -> datetime
    """
    if not txt:
        return None
    txt = txt.strip()
    for fmt in ("%d/%m/%Y %H:%M:%S", "%d/%m/%Y %H:%M"):
        try:
            return datetime.strptime(txt, fmt)
        except Exception:
            pass
    return None


def _month_bounds(d: datetime) -> Tuple[datetime, datetime]:
    ini = d.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    if d.month == 12:
        prox = d.replace(year=d.year + 1, month=1, day=1)
    else:
        prox = d.replace(month=d.month + 1, day=1)
    fim = prox - timedelta(seconds=1)
    return ini, fim


def _fdate(d: datetime) -> str:
    return d.strftime("%d/%m/%Y")


# ------------------------------------------------------------
# PortalClient
# ------------------------------------------------------------
class PortalClient:
    """
    Cliente Selenium para o portal FieldMap mobile.
    Políticas importantes:
      - Nunca anexa se não achar a *janela de horário* compatível.
      - Nunca usa “última linha” como fallback.
    """

    def __init__(self, config_path="config.yaml", headless: bool = False):
        with open(config_path, "r", encoding="utf-8") as f:
            self.cfg = yaml.safe_load(f) or {}

        self.base_url = self.cfg.get("tabela", {}).get(
            "url", "https://mobile.ncratleos.com/sb0121/Deslocamento/Index"
        )
        self.login_url = self.cfg.get("login", {}).get(
            "url", "https://mobile.ncratleos.com/sb0121/"
        )

        self.user_sel = self.cfg.get("login", {}).get("user_selector", "input#UserName")
        self.pass_sel = self.cfg.get("login", {}).get("pass_selector", "input#Password")
        self.submit_sel = self.cfg.get("login", {}).get(
            "submit_selector", "button[type='submit']"
        )

        self.row_selector = self.cfg.get("tabela", {}).get("row_selector", "table tbody tr")

        self.form_tipo_sel = self.cfg.get("form", {}).get("tipo_selector", "select#Tipo")
        self.form_valor_sel = self.cfg.get("form", {}).get("valor_selector", "input#Valor")
        self.form_anexar_sel = self.cfg.get("form", {}).get(
            "anexar_input_selector", "input[type='file']"
        )
        self.form_salvar_sel = self.cfg.get("form", {}).get(
            "salvar_selector", "button.btn.btn-success[type='submit']"
        )

        self.driver = self._make_driver(headless=headless)
        self.wait = WebDriverWait(self.driver, 20)

        try:
            self.driver.set_window_size(1440, 900)
        except Exception:
            pass

    # --------------------- Driver ---------------------
    def _make_driver(self, headless: bool) -> webdriver.Firefox:
        o = Options()
        if headless:
            o.add_argument("--headless")
            o.add_argument("--window-size=1400,950")
            o.set_preference(
                "general.useragent.override",
                "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0",
            )

        # usa caminhos fornecidos via systemd/.env
        firefox_bin = os.environ.get("FIREFOX_BIN")  # ex.: /usr/bin/firefox-esr
        if firefox_bin:
            o.binary_location = firefox_bin

        gecko_path = os.environ.get("GECKODRIVER", "/usr/local/bin/geckodriver")
        service = Service(executable_path=gecko_path)

        # passando Service evita o Selenium Manager (problema no aarch64)
        driver = webdriver.Firefox(options=o, service=service)
        return driver

    # --------------------- Utils básicos ---------------------
    def _scroll_center(self, el):
        try:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
        except Exception:
            pass

    def _js_click(self, el):
        self.driver.execute_script("arguments[0].click();", el)

    def _robust_click(self, el):
        try:
            ActionChains(self.driver).move_to_element(el).pause(0.04).click(el).perform()
        except Exception:
            self._js_click(el)

    def _set_input_value_js(self, el, value_str: str):
        self.driver.execute_script(
            """
            const el = arguments[0], v = arguments[1];
            el.value = v;
            el.dispatchEvent(new Event('input', {bubbles:true}));
            el.dispatchEvent(new Event('change', {bubbles:true}));
            """,
            el,
            value_str,
        )

    # --------------------- Login ---------------------
    def _is_login_page(self) -> bool:
        """
        Heurística robusta para saber se estamos na tela de login.
        """
        try:
            url = (self.driver.current_url or "").rstrip("/")
            if url.endswith("/sb0121") or "/Account/Login" in url:
                return True
            title_ok = "login - fieldmap web" in (self.driver.title or "").lower()
            has_user = bool(self.driver.find_elements(By.CSS_SELECTOR, "input#UserName"))
            has_pass = bool(self.driver.find_elements(By.CSS_SELECTOR, "input#Password"))
            return title_ok and (has_user and has_pass)
        except Exception:
            return False

    def login(self):
        user = os.getenv("PORTAL_USER")
        pwd = os.getenv("PORTAL_PASS")
        if not user or not pwd:
            raise RuntimeError("Credenciais ausentes (.env: PORTAL_USER/PORTAL_PASS).")

        # vai sempre para a URL de login
        self.driver.get(self.login_url)
        self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, self.user_sel)))

        u = self.driver.find_element(By.CSS_SELECTOR, self.user_sel)
        p = self.driver.find_element(By.CSS_SELECTOR, self.pass_sel)

        u.clear(); u.send_keys(user)
        p.clear(); p.send_keys(pwd)

        # tenta click normal; se falhar, usa JS
        try:
            btn = self.driver.find_element(By.CSS_SELECTOR, self.submit_sel)
            self._robust_click(btn)
        except Exception:
            self.driver.execute_script("document.querySelector(arguments[0])?.click()", self.submit_sel)

        # espera REALMENTE sair da tela de login
        self.wait.until(lambda d: not self._is_login_page())

    def ensure_logged(self):
        """
        Garante sessão autenticada.
        """
        if self._is_login_page():
            self.login()
            return
        try:
            self.wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))
        except Exception:
            self.login()

    # --------------------- Grade/lista ---------------------
    def _esperar_grade_pronta(self, timeout: int = None) -> bool:
        """
        Aguarda a grid de Deslocamentos:
        - 1+ <tr> no tbody = pronta (com linhas)
        - célula .dataTables_empty = pronta (vazia)
        """
        d = self.driver
        row_sel = self.row_selector

        if timeout is None:
            timeout = int(self.cfg.get("tabela", {}).get("wait_ready_seconds", 30) or 30)

        table_sel = "table, table#datatable, table.dataTable"
        empty_sel = "td.dataTables_empty, tr.dataTables_empty, .dataTables_empty"

        end_time = time.time() + timeout
        last_exc = None

        while time.time() < end_time:
            try:
                WebDriverWait(d, 8).until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, table_sel))
                )

                rows = d.find_elements(By.CSS_SELECTOR, row_sel)
                if rows:
                    return True

                if d.find_elements(By.CSS_SELECTOR, empty_sel):
                    return False

                time.sleep(0.4)

            except (TimeoutException, StaleElementReferenceException) as e:
                last_exc = e
                time.sleep(0.5)
            except Exception as e:
                last_exc = e
                time.sleep(0.3)

        # dumps de debug
        try:
            with open("debug_grid_timeout.html", "w", encoding="utf-8") as f:
                f.write(d.page_source)
            try:
                d.save_screenshot("debug_grid_timeout.png")
            except Exception:
                pass
        except Exception:
            pass

        raise TimeoutException("Grade não ficou pronta (sem linhas nem 'sem registros').") from last_exc

    def ensure_on_deslocamento_index(self):
        """
        Vai para /Deslocamento/Index; se cair no login, autentica e volta.
        """
        self.driver.get(self.base_url)
        if self._is_login_page():
            self.login()
            self.driver.get(self.base_url)
        self.wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))

    # --------------------- Parsing de linha ---------------------
    def _parse_linha(self, tr) -> Tuple[Optional[datetime], Optional[datetime]]:
        """
        Retorna (inicio, fim) das duas primeiras colunas.
        """
        try:
            tds = tr.find_elements(By.TAG_NAME, "td")
            if len(tds) < 2:
                return None, None
            ini = _br_date_to_dt((tds[0].text or "").strip())
            fim = _br_date_to_dt((tds[1].text or "").strip())
            return ini, fim
        except Exception:
            return None, None

    def _open_menu_and_get_despesas(self, row_el, dt_ini: datetime) -> Optional[str]:
        """
        Abre o menu da linha e retorna o HREF de /Despesa/.
        Tenta priorizar o link que já vem com data/hora codificadas.
        """
        # botão do dropdown
        btn = None
        for sel in (
            "button.btn.btn-success.dropdown-toggle",
            "button.btn.dropdown-toggle",
            "button.dropdown-toggle",
        ):
            f = row_el.find_elements(By.CSS_SELECTOR, sel)
            if f:
                btn = f[0]
                break
        if not btn:
            return None

        self._scroll_center(row_el)
        try:
            self._robust_click(btn)
        except Exception:
            self._js_click(btn)

        # menu aberto
        menu = None
        for sel in (".dropdown-menu.show", "ul.dropdown-menu"):
            try:
                menu = WebDriverWait(self.driver, 4).until(
                    EC.visibility_of_element_located((By.CSS_SELECTOR, sel))
                )
                break
            except TimeoutException:
                pass
        if not menu:
            return None

        # procura link de /Despesa/
        links = menu.find_elements(By.CSS_SELECTOR, "a.dropdown-item, a, button")
        best, fallback = None, None
        enc_date = f"{dt_ini.month:02d}%2F{dt_ini.day:02d}%2F{dt_ini.year}"
        enc_hhmm = f"{dt_ini.hour:02d}%3A{dt_ini.minute:02d}"
        for a in links:
            href = (a.get_attribute("href") or "")
            text = (a.text or "").lower()
            if "/Despesa/" in href:
                if "dataInicio=" in href and enc_date in href and enc_hhmm in href:
                    best = href
                    break
                if fallback is None:
                    fallback = href
            elif "despesa" in text and fallback is None:
                fallback = href
        return best or fallback

    # --------------------- Localização da linha por data/hora ---------------------
    def encontrar_linha_por_data_hora(self, dt_evento: datetime, tipo: str) -> Optional[str]:
        """
        Seleciona a linha correta para anexar:
          - pedagio: janela [ini, fim] do próprio deslocamento;
          - estacionamento: janela [fim_atual, ini_proximo);
            * no último deslocamento, aceita [fim_ultimo, +inf).
        Para evitar StaleElementReference, guardamos apenas o ÍNDICE da linha e,
        na hora do clique, rebuscamos o <tr>.
        """
        d = self.driver

        # 1) garantir /Deslocamento/Index no mês do evento
        self.ensure_on_deslocamento_index()
        self._fixar_periodo_do_mes(dt_evento)

        # 2) esperar a grade ficar pronta
        if not self._esperar_grade_pronta(timeout=int(self.cfg.get("tabela", {}).get("wait_ready_seconds", 30) or 30)):
            return None

        row_sel = self.row_selector
        rows = d.find_elements(By.CSS_SELECTOR, row_sel)
        if not rows:
            return None

        def _safe_text(el) -> str:
            for _ in range(2):
                try:
                    return (el.text or "").strip()
                except Exception:
                    time.sleep(0.05)
            return ""

        # 3) snapshot lógico das linhas: (ini, fim, idx)
        segmentos: List[Tuple[datetime, datetime, int]] = []
        for idx in range(len(rows)):
            try:
                rows_now = d.find_elements(By.CSS_SELECTOR, row_sel)
                if idx >= len(rows_now):
                    break
                tr = rows_now[idx]
                tds = tr.find_elements(By.TAG_NAME, "td")
            except StaleElementReferenceException:
                continue

            ini = None
            fim = None
            if len(tds) >= 2:
                ini = _br_date_to_dt(_safe_text(tds[0]))
                fim = _br_date_to_dt(_safe_text(tds[1]))

            # fallback por regex se não parseou direto
            if not ini or not fim:
                bloco = " | ".join(_safe_text(td) for td in tds[:4])
                m = DATETIME_RX.findall(bloco)
                if m:
                    try:
                        ini = datetime.strptime(" ".join(m[0]), "%d/%m/%Y %H:%M:%S")
                        fim = datetime.strptime(" ".join(m[1] if len(m) > 1 else m[0]), "%d/%m/%Y %H:%M:%S")
                    except Exception:
                        ini = fim = None

            if ini and fim:
                if fim < ini:
                    ini, fim = fim, ini
                segmentos.append((ini, fim, idx))

        if not segmentos:
            return None

        # 4) ordena por início
        segmentos.sort(key=lambda t: t[0])

        alvo_tipo = (tipo or "").strip().lower()

        # ---------- pedágio: [ini, fim] contém o evento ----------
        if "pedag" in alvo_tipo:
            candidatos = [(ini, fim, idx) for (ini, fim, idx) in segmentos if ini <= dt_evento <= fim]
            if not candidatos:
                return None
            # escolhe a menor janela que contém o ponto
            candidatos.sort(key=lambda t: (t[1] - t[0]).total_seconds())
            ini, fim, idx = candidatos[0]
            rows_now = d.find_elements(By.CSS_SELECTOR, row_sel)
            if idx >= len(rows_now):
                return None
            tr = rows_now[idx]
            return self._open_menu_and_get_despesas(tr, ini)

        # ----- estacionamento: [fim_atual, ini_proximo) contém o evento -----
        if "estaciona" in alvo_tipo:
            for i, (ini, fim, idx) in enumerate(segmentos):
                prox_ini = segmentos[i + 1][0] if i + 1 < len(segmentos) else None
                if prox_ini:
                    # janela entre deslocamentos
                    if fim <= dt_evento < prox_ini:
                        rows_now = d.find_elements(By.CSS_SELECTOR, row_sel)
                        if idx >= len(rows_now):
                            return None
                        tr = rows_now[idx]
                        return self._open_menu_and_get_despesas(tr, ini)
                else:
                    # último deslocamento: aceita [fim_ultimo, +inf)
                    if dt_evento >= fim:
                        rows_now = d.find_elements(By.CSS_SELECTOR, row_sel)
                        if idx >= len(rows_now):
                            return None
                        tr = rows_now[idx]
                        return self._open_menu_and_get_despesas(tr, ini)
            return None

        # tipos desconhecidos -> fallback "tipo pedágio"
        for ini, fim, idx in segmentos:
            if ini <= dt_evento <= fim:
                rows_now = d.find_elements(By.CSS_SELECTOR, row_sel)
                if idx >= len(rows_now):
                    return None
                tr = rows_now[idx]
                return self._open_menu_and_get_despesas(tr, ini)
        return None

    # --------------------- Filtro do período ---------------------
    def _fixar_periodo_do_mes(self, ref: datetime):
        """
        Preenche os campos dataInicialPesquisa/dataFinalPesquisa para o mês de 'ref'
        e dispara 'Pesquisar' se existir.
        """
        d = self.driver
        try:
            inp_ini = d.find_element(
                By.CSS_SELECTOR, "input#dataInicialPesquisa, input[name='dataInicialPesquisa']"
            )
            inp_fim = d.find_element(
                By.CSS_SELECTOR, "input#dataFinalPesquisa, input[name='dataFinalPesquisa']"
            )
        except Exception:
            return

        ini, fim = _month_bounds(ref)
        self._set_input_value_js(inp_ini, _fdate(ini))
        self._set_input_value_js(inp_fim, _fdate(fim))

        try:
            btn_p = d.find_element(By.CSS_SELECTOR, "button#btnPesquisar, button[type='submit']")
            self._robust_click(btn_p)
            time.sleep(0.6)
        except Exception:
            pass

    # --------------------- Normalização/Tipo ---------------------
    def _norm(self, s: str) -> str:
        repl = (
            ("á", "a"), ("à", "a"), ("â", "a"), ("ã", "a"),
            ("é", "e"), ("ê", "e"),
            ("í", "i"),
            ("ó", "o"), ("ô", "o"), ("õ", "o"),
            ("ú", "u"),
            ("ç", "c"),
        )
        s = (s or "").lower()
        for a, b in repl:
            s = s.replace(a, b)
        return s

    def _choose_tipo_option(self, select_el, tipo: str) -> bool:
        """
        Escolhe a opção correta do select de Tipo:
        - 'pedágio' => option cujo texto contenha 'pedag'
        - 'estacionamento' => option contendo 'estaciona'
        Fallback por atributo value ('2' para pedágio, '1' para estacionamento).
        """
        alvo = self._norm(tipo)
        alvo_key = "pedag" if "pedag" in alvo else "estaciona"

        options = select_el.find_elements(By.TAG_NAME, "option")
        cand = []
        for opt in options:
            txtn = self._norm(opt.text)
            if alvo_key in txtn:
                cand.append((len(txtn), opt))  # prefere o texto mais específico
        if cand:
            cand.sort(reverse=True)
            self._robust_click(cand[0][1])
            return True

        wanted_val = "2" if alvo_key == "pedag" else "1"
        for opt in options:
            if (opt.get_attribute("value") or "").strip() == wanted_val:
                self._robust_click(opt)
                return True
        return False

    # --------------------- Abrir despesas por HREF ---------------------
    def abrir_despesas_por_href(self, href: str) -> bool:
        self.ensure_logged()
        self.driver.get(href)
        try:
            self.wait.until(lambda drv: "/Despesa/Index" in (drv.current_url or ""))
            return True
        except TimeoutException:
            return False

    # --------------------- Preencher + anexar + validação ---------------------
    def preencher_e_anexar(
        self, tipo: str, valor_centavos: int, arquivo: str, data_evento: Optional[datetime] = None
    ) -> bool:
        """
        Preenche o formulário de despesa, anexa e valida no retorno:
          (1) existe uma linha com tipo+valor e
          (2) há seção de 'Comprovantes' visível ao abrir a edição.
        """
        d, w = self.driver, self.wait

        url = d.current_url or ""
        if "/Despesa/" not in url:
            return False

        # se estamos na lista, clicar em +Nova Despesa
        if "/Despesa/Index" in url:
            try:
                btn_sel = "a[href*='/Despesa/New'], a.center-block.btn.btn-success[href*='/Despesa/New']"
                novo = w.until(EC.element_to_be_clickable((By.CSS_SELECTOR, btn_sel)))
            except TimeoutException:
                novo = w.until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "//a[contains(., '+ Nova Despesa') or contains(., 'Nova Despesa')]")
                    )
                )
            self._scroll_center(novo)
            self._robust_click(novo)
            w.until(lambda drv: "/Despesa/New" in (drv.current_url or ""))

        # Tipo tolerante
        tipo_select = w.until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "select#Tipo, select[name='Tipo']"))
        )
        try:
            if not self._choose_tipo_option(tipo_select, tipo):
                return False
        except Exception:
            return False

        # Valor (pt-BR)
        valor_input = w.until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "input#Valor, input[name='Valor']"))
        )
        try:
            valor_input.clear()
        except Exception:
            pass
        valor_fmt = f"{valor_centavos/100:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        valor_input.send_keys(valor_fmt)

        # Anexo
        file_input = w.until(EC.presence_of_element_located((By.CSS_SELECTOR, self.form_anexar_sel)))
        file_input.send_keys(os.path.abspath(arquivo))

        # Salvar
        try:
            salvar = w.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
        except TimeoutException:
            return False
        self._scroll_center(salvar)
        self._robust_click(salvar)

        # Confirma retorno à grade
        try:
            w.until(lambda drv: "/Despesa/Index" in (drv.current_url or ""))
        except TimeoutException:
            if "/Despesa/Save" in (d.current_url or ""):
                return False

        # Validação: existe linha com tipo+valor?
        try:
            w.until(EC.presence_of_element_located((By.CSS_SELECTOR, "table, table#datatable, table.dataTable")))
            for _ in range(10):
                linhas = d.find_elements(By.CSS_SELECTOR, "table tbody tr")
                alvo_key = "pedag" if "pedag" in self._norm(tipo) else "estacion"
                for tr in linhas:
                    tds = tr.find_elements(By.TAG_NAME, "td")
                    if not tds:
                        continue
                    txt = " | ".join((td.text or "") for td in tds)
                    if (alvo_key in txt.lower()) and (valor_fmt in txt):
                        # Validação extra: abrir a linha recém criada e conferir o anexo
                        ref_dt = _br_date_to_dt((tds[0].text or "").strip()) or datetime.now()
                        href = self._open_menu_and_get_despesas(tr, ref_dt)
                        if not href:
                            return True  # já bateu tipo+valor
                        self.driver.get(href.replace("/Index", "/Editar"))
                        try:
                            w.until(EC.presence_of_element_located((By.CSS_SELECTOR, "div#Comprovantes, #Comprovantes")))
                        except TimeoutException:
                            return True
                        if "Comprovantes" in (d.page_source or ""):
                            return True
                time.sleep(0.6)
        except Exception:
            pass

        return False
